<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<title>ti.kit.repo API documentation</title>
<meta name="description" content="" />
<!-- integrity SRI from https://cdnjs.com/libraries/10up-sanitize.css/11.0.1 -->
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha512-kcbluZFacWN57NgWZ4aH6eUMBEaTyErFhIFD3y5qYZbKuuyImH0K/AKsBbfXlivh2z5C+3IDTIhI11YmKomzmA=="
crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha512-uVeAgzAmieLUTGba0qr9vXQgVD7fko2kcbYIKIraXUIDg9iJLxveTFUrg3DJhqn3cAf3HFDbgmhq0eGko5wEAA=="
crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ti.kit.repo</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L1-L356" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import io
import re
from zipfile import ZipFile
from shutil import rmtree
import requests
import ssl

from gitlab import Gitlab, GitlabGetError

from .helpers import console as consoleKit
from .files import chDir, getCwd, dirRemove

VERSION_DIGIT_RE = re.compile(r&#34;^([0-9]+).*&#34;)
SHELL_VAR_RE = re.compile(r&#34;[^A-Z0-9_]&#34;)
CHECK_FILE = &#34;/__checkout__.txt&#34;


def initTree(path, fresh=False, gentle=False):
    exists = os.path.exists(path)

    if fresh and exists:
        rmtree(path)

    if not exists or fresh:
        os.makedirs(path, exist_ok=True)


def GLPERS(backend):
    return f&#34;GL_{SHELL_VAR_RE.sub(&#39;_&#39;, backend.upper())}_PERS&#34;


def readSha(folder):
    path = f&#34;{folder}/{CHECK_FILE}&#34;
    commit = None

    if os.path.isfile(path):
        with open(path) as f:
            for line in f:
                text = line.strip()

                if text:
                    commit = text
                    break

    return commit


def writeSha(folder, commit):
    path = f&#34;{folder}/{CHECK_FILE}&#34;

    if not os.path.isdir(folder):
        os.makedirs(folder, exist_ok=True)

    with open(path, mode=&#34;w&#34;) as f:
        f.write(f&#34;{commit}\n&#34;)


def fetchRepo(
    backend, org, repo, folder, destDir, force=False, verbose=False, indent=&#34;&#34;
):
    &#34;&#34;&#34;Get latest version of a subfolder of a GitLab repo.

    Before downloading the data, the commit hash of the online data and the
    local copy will be compared. If they are equal, the download will
    not happen, except when the `force` parameter is nonzero.

    After download, the commit hash will be written to the downloaded folder.

    If the folder is deep into the repo, say `/a/b/c/folder`,
    the zip file returned by GitLab will have paths `/a/b/c/folder/`... .

    The extraction will remove `/a/b/c` from these paths.
    After the extraction, a file __checkout__.txt containing the commit hash
    will be placed in the `destDir/folder` directory.

    Parameters
    ----------
    backend: string
        The name of an on-premiss gitlab server, e.g. gitlab.huc.knaw.nl
    org: string
        Organization or group on gitlab
    repo: string
        Repository within organization or group
    folder: string
        Subdirectory within repo
    destDir: string
        Local directory where the downloaded data should land
    force: boolean, optional False
        Whether to force downloading data if the local copy matches the online copy
        by sha-hash.

        If `False`: no re-download will take place. Otherwise the folder
        will be downloaded again.

        If `True`, the folder will be downloaded again, but the local copy will
        not be wiped on beforehand, so new files will overwrite existing files,
        but if the local copy contains additional material, it will be left in place.
    verbose: boolean, optional False
        If True, informational messages will be issued, otherwise only error messages
        will be issued.
    indent: string, optional &#34;&#34;
        Precede each console message with this string (usually a bunch of spaces)

    Returns
    -------
    bool | void
        A boolean indicating Whether the operation was successful.
        However, if the repo exists, but the subfolder does not exist in the repo,
        and the requests succeeds, but yields empty data, `None` is returned.
    &#34;&#34;&#34;

    def console(*msg, error=False, newline=True):
        consoleKit(*msg, error=error, newline=newline, indent=indent)

    conn = None

    bUrl = f&#34;https://{backend}&#34;
    onlineSrc = f&#34;{bUrl}/{org}/{repo}&#34;
    person = os.environ.get(GLPERS(backend), None)

    if person:
        conn = Gitlab(bUrl, private_token=person, keep_base_url=True)
    else:
        conn = Gitlab(bUrl)

    backendVersion = conn.version()

    if (
        not backendVersion
        or backendVersion[0] == &#34;unknown&#34;
        or backendVersion[-1] == &#34;unknown&#34;
    ):
        conn = None
        console(f&#34;cannot connect to GitLab instance {bUrl}\n&#34;, error=True)
        return False

    if verbose:
        console(f&#34;connected to {bUrl}&#34;)

    repoOnline = None

    try:
        repoOnline = conn.projects.get(f&#34;{org}/{repo}&#34;)
    except Exception as e:
        console(f&#34;connecting failed to online {onlineSrc}&#34;, error=True)

        if type(e) is GitlabGetError:
            console(f&#34;{bUrl} says: {e}&#34;, error=True)
        else:
            console(f&#34;error with {bUrl}: {e}&#34;, error=True)

        return False

    if verbose:
        console(f&#34;connected to {onlineSrc}&#34;)

    commit = None

    try:
        cs = repoOnline.commits.list(all=True)

        if not len(cs):
            console(f&#34;no commit in {onlineSrc}&#34;, error=True)
        else:
            cs = sorted(cs, key=lambda x: x.created_at)

            if len(cs):
                commit = cs[-1]
    except Exception as e:
        console(str(e), error=True)

    if commit is None:
        console(f&#34;cannot find commits in {onlineSrc}&#34;, error=True)
        return False

    sha = commit.id

    if verbose:
        console(f&#34;{sha} = latest commit online&#34;)

    destDir = os.path.expanduser(destDir)
    (folderHead, folderTail) = folder.rsplit(&#34;/&#34;, 1) if &#34;/&#34; in folder else (&#34;&#34;, folder)

    folderLocal = f&#34;{destDir}/{folderTail}&#34;
    existingSha = readSha(folderLocal)

    if verbose:
        console(f&#34;{existingSha} = commit of local copy&#34;)

    localOk = existingSha == sha
    removeLocal = False

    if localOk:
        if verbose:
            console(&#34;Offline copy already up to date&#34;)

        if not force:
            return True
        else:
            console(&#34;Will download again over local copy&#34;)
    else:
        if verbose:
            console(&#34;Offline copy not up to date, will download new copy&#34;)

        removeLocal = True

    try:
        if verbose:
            console(f&#34;Downloading {onlineSrc}/{folder} ... &#34;, newline=False)

        response = conn.http_get(
            f&#34;/projects/{repoOnline.id}/repository/archive.zip&#34;,
            query_data=dict(path=folder),
            raw=True,
        )
        zf = response.content
    except Exception as e:
        if verbose:
            console(&#34;failed&#34;, error=True)

        console(str(e), error=True)
        return False

    if verbose:
        console(&#34;done&#34;)

    if len(zf) == 0:
        console(&#34;Download is empty&#34;)
        return None

    initTree(folderLocal, fresh=removeLocal)

    if verbose:
        console(f&#34;Extracting data to {folderLocal} ... &#34;, newline=False)

    try:
        zf = io.BytesIO(zf)
        z = ZipFile(zf)

        folderHeadSlash = f&#34;{folderHead}/&#34; if folderHead else &#34;&#34;
        gitlabSlugRe = re.compile(f&#34;^{repo}(?:-(?:master|main))?-[^/]*/&#34;)

        for zInfo in z.infolist():
            fileName = zInfo.filename

            if fileName.endswith(&#34;/&#34;):
                continue

            fileName = gitlabSlugRe.sub(&#34;&#34;, fileName) or &#34;/&#34;
            fileName = fileName.removeprefix(folderHeadSlash)
            zInfo.filename = fileName
            z.extract(zInfo, path=destDir)

        writeSha(folderLocal, sha)

    except Exception as e:
        if verbose:
            console(&#34;failed&#34;, error=True)

        console(str(e), error=True)
        return False

    if verbose:
        console(&#34;done&#34;)

    return True


def downloadZip(
    org, repo, release, file, dest, force=False, fresh=False, verbose=False
):
    &#34;&#34;&#34;Download a zip file from a release on github and unpack it.

    Parameters
    ----------
    org: string
        Organization on GitHub
    repo: string
        Repository within organization
    release: string
        The release version of the data to be downloaded.
    file: string
        The filename of the release attachment to fetch, without extension.
        The extension must be `.zip`
    dest: string
        The destination directory under which the contents of the zip is extracted.
    force: boolean, optional False
        Whether to force downloading data if the local copy matches the online copy
        by release version.

        If `False`: no re-download will take place. Otherwise the folder
        will be downloaded again.

        If `True`, the folder will be downloaded again, but the local copy will
        not be wiped on beforehand, so new files will overwrite existing files,
        but if the local copy contains additional material, it will be left in place.
    fresh: boolean, optional False
        Whether to clean the destination directory before extracting
    verbose: boolean, optional False
        If True, informational messages will be issued, otherwise only error messages
        will be issued.

    Returns
    -------
    boolean
        Whether the download and extraction was successful
    &#34;&#34;&#34;
    url = f&#34;https://github.com/{org}/{repo}/releases/download/{release}/{file}.zip&#34;

    ssl._create_default_https_context = ssl._create_unverified_context
    console = consoleKit
    existingRelease = readSha(dest)

    if existingRelease == release and not force and not fresh:
        if verbose:
            console(f&#34;Data already present: {release}/{file}.zip&#34;)
        return True

    cwd = getCwd()

    status = dict(downloaded=False, extracted=False)
    good = False

    try:
        r = requests.get(url, allow_redirects=True)
        if not r.ok:
            console(f&#34;{r.reason}\n\tcould not download {url}&#34;, error=True)
        else:
            zf = r.content
            if verbose:
                console(f&#34;{release}/{file}.zip downloaded having {len(zf)} bytes&#34;)

            status[&#34;downloaded&#34;] = True
            zf = io.BytesIO(zf)
            z = ZipFile(zf)
            initTree(dest, fresh=fresh)
            chDir(dest)
            z.extractall()
            status[&#34;extracted&#34;] = True
            dirRemove(&#34;__MACOSX&#34;)
            chDir(cwd)
            writeSha(dest, release)
            good = True
    except Exception as e:
        if not status[&#34;downloaded&#34;]:
            console(f&#34;{str(e)}\n\tcould not download {url}&#34;, error=True)
        elif not status[&#34;extracted&#34;]:
            console(f&#34;{str(e)}\n\tcould not extract to {dest}&#34;, error=True)
        else:
            console(f&#34;{str(e)} could not complete the operation&#34;, error=True)

        good = False
        chDir(cwd)

    return good</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ti.kit.repo.GLPERS"><code class="name flex">
<span>def <span class="ident">GLPERS</span></span>(<span>backend)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L29-L30" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def GLPERS(backend):
    return f&#34;GL_{SHELL_VAR_RE.sub(&#39;_&#39;, backend.upper())}_PERS&#34;</code></pre>
</details>
</dd>
<dt id="ti.kit.repo.downloadZip"><code class="name flex">
<span>def <span class="ident">downloadZip</span></span>(<span>org, repo, release, file, dest, force=False, fresh=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Download a zip file from a release on github and unpack it.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code></dt>
<dd>Organization on GitHub</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string</code></dt>
<dd>Repository within organization</dd>
<dt><strong><code>release</code></strong> :&ensp;<code>string</code></dt>
<dd>The release version of the data to be downloaded.</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>string</code></dt>
<dd>The filename of the release attachment to fetch, without extension.
The extension must be <code>.zip</code></dd>
<dt><strong><code>dest</code></strong> :&ensp;<code>string</code></dt>
<dd>The destination directory under which the contents of the zip is extracted.</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>Whether to force downloading data if the local copy matches the online copy
by release version.</p>
<p>If <code>False</code>: no re-download will take place. Otherwise the folder
will be downloaded again.</p>
<p>If <code>True</code>, the folder will be downloaded again, but the local copy will
not be wiped on beforehand, so new files will overwrite existing files,
but if the local copy contains additional material, it will be left in place.</p>
</dd>
<dt><strong><code>fresh</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>Whether to clean the destination directory before extracting</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, informational messages will be issued, otherwise only error messages
will be issued.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>boolean</code></dt>
<dd>Whether the download and extraction was successful</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L270-L356" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downloadZip(
    org, repo, release, file, dest, force=False, fresh=False, verbose=False
):
    &#34;&#34;&#34;Download a zip file from a release on github and unpack it.

    Parameters
    ----------
    org: string
        Organization on GitHub
    repo: string
        Repository within organization
    release: string
        The release version of the data to be downloaded.
    file: string
        The filename of the release attachment to fetch, without extension.
        The extension must be `.zip`
    dest: string
        The destination directory under which the contents of the zip is extracted.
    force: boolean, optional False
        Whether to force downloading data if the local copy matches the online copy
        by release version.

        If `False`: no re-download will take place. Otherwise the folder
        will be downloaded again.

        If `True`, the folder will be downloaded again, but the local copy will
        not be wiped on beforehand, so new files will overwrite existing files,
        but if the local copy contains additional material, it will be left in place.
    fresh: boolean, optional False
        Whether to clean the destination directory before extracting
    verbose: boolean, optional False
        If True, informational messages will be issued, otherwise only error messages
        will be issued.

    Returns
    -------
    boolean
        Whether the download and extraction was successful
    &#34;&#34;&#34;
    url = f&#34;https://github.com/{org}/{repo}/releases/download/{release}/{file}.zip&#34;

    ssl._create_default_https_context = ssl._create_unverified_context
    console = consoleKit
    existingRelease = readSha(dest)

    if existingRelease == release and not force and not fresh:
        if verbose:
            console(f&#34;Data already present: {release}/{file}.zip&#34;)
        return True

    cwd = getCwd()

    status = dict(downloaded=False, extracted=False)
    good = False

    try:
        r = requests.get(url, allow_redirects=True)
        if not r.ok:
            console(f&#34;{r.reason}\n\tcould not download {url}&#34;, error=True)
        else:
            zf = r.content
            if verbose:
                console(f&#34;{release}/{file}.zip downloaded having {len(zf)} bytes&#34;)

            status[&#34;downloaded&#34;] = True
            zf = io.BytesIO(zf)
            z = ZipFile(zf)
            initTree(dest, fresh=fresh)
            chDir(dest)
            z.extractall()
            status[&#34;extracted&#34;] = True
            dirRemove(&#34;__MACOSX&#34;)
            chDir(cwd)
            writeSha(dest, release)
            good = True
    except Exception as e:
        if not status[&#34;downloaded&#34;]:
            console(f&#34;{str(e)}\n\tcould not download {url}&#34;, error=True)
        elif not status[&#34;extracted&#34;]:
            console(f&#34;{str(e)}\n\tcould not extract to {dest}&#34;, error=True)
        else:
            console(f&#34;{str(e)} could not complete the operation&#34;, error=True)

        good = False
        chDir(cwd)

    return good</code></pre>
</details>
</dd>
<dt id="ti.kit.repo.fetchRepo"><code class="name flex">
<span>def <span class="ident">fetchRepo</span></span>(<span>backend, org, repo, folder, destDir, force=False, verbose=False, indent='')</span>
</code></dt>
<dd>
<div class="desc"><p>Get latest version of a subfolder of a GitLab repo.</p>
<p>Before downloading the data, the commit hash of the online data and the
local copy will be compared. If they are equal, the download will
not happen, except when the <code>force</code> parameter is nonzero.</p>
<p>After download, the commit hash will be written to the downloaded folder.</p>
<p>If the folder is deep into the repo, say <code>/a/b/c/folder</code>,
the zip file returned by GitLab will have paths <code>/a/b/c/folder/</code>&hellip; .</p>
<p>The extraction will remove <code>/a/b/c</code> from these paths.
After the extraction, a file <strong>checkout</strong>.txt containing the commit hash
will be placed in the <code>destDir/folder</code> directory.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>backend</code></strong> :&ensp;<code>string</code></dt>
<dd>The name of an on-premiss gitlab server, e.g. gitlab.huc.knaw.nl</dd>
<dt><strong><code>org</code></strong> :&ensp;<code>string</code></dt>
<dd>Organization or group on gitlab</dd>
<dt><strong><code>repo</code></strong> :&ensp;<code>string</code></dt>
<dd>Repository within organization or group</dd>
<dt><strong><code>folder</code></strong> :&ensp;<code>string</code></dt>
<dd>Subdirectory within repo</dd>
<dt><strong><code>destDir</code></strong> :&ensp;<code>string</code></dt>
<dd>Local directory where the downloaded data should land</dd>
<dt><strong><code>force</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>
<p>Whether to force downloading data if the local copy matches the online copy
by sha-hash.</p>
<p>If <code>False</code>: no re-download will take place. Otherwise the folder
will be downloaded again.</p>
<p>If <code>True</code>, the folder will be downloaded again, but the local copy will
not be wiped on beforehand, so new files will overwrite existing files,
but if the local copy contains additional material, it will be left in place.</p>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>boolean</code>, optional <code>False</code></dt>
<dd>If True, informational messages will be issued, otherwise only error messages
will be issued.</dd>
<dt><strong><code>indent</code></strong> :&ensp;<code>string</code>, optional <code>""</code></dt>
<dd>Precede each console message with this string (usually a bunch of spaces)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool | void</code></dt>
<dd>A boolean indicating Whether the operation was successful.
However, if the repo exists, but the subfolder does not exist in the repo,
and the requests succeeds, but yields empty data, <code>None</code> is returned.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L59-L267" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fetchRepo(
    backend, org, repo, folder, destDir, force=False, verbose=False, indent=&#34;&#34;
):
    &#34;&#34;&#34;Get latest version of a subfolder of a GitLab repo.

    Before downloading the data, the commit hash of the online data and the
    local copy will be compared. If they are equal, the download will
    not happen, except when the `force` parameter is nonzero.

    After download, the commit hash will be written to the downloaded folder.

    If the folder is deep into the repo, say `/a/b/c/folder`,
    the zip file returned by GitLab will have paths `/a/b/c/folder/`... .

    The extraction will remove `/a/b/c` from these paths.
    After the extraction, a file __checkout__.txt containing the commit hash
    will be placed in the `destDir/folder` directory.

    Parameters
    ----------
    backend: string
        The name of an on-premiss gitlab server, e.g. gitlab.huc.knaw.nl
    org: string
        Organization or group on gitlab
    repo: string
        Repository within organization or group
    folder: string
        Subdirectory within repo
    destDir: string
        Local directory where the downloaded data should land
    force: boolean, optional False
        Whether to force downloading data if the local copy matches the online copy
        by sha-hash.

        If `False`: no re-download will take place. Otherwise the folder
        will be downloaded again.

        If `True`, the folder will be downloaded again, but the local copy will
        not be wiped on beforehand, so new files will overwrite existing files,
        but if the local copy contains additional material, it will be left in place.
    verbose: boolean, optional False
        If True, informational messages will be issued, otherwise only error messages
        will be issued.
    indent: string, optional &#34;&#34;
        Precede each console message with this string (usually a bunch of spaces)

    Returns
    -------
    bool | void
        A boolean indicating Whether the operation was successful.
        However, if the repo exists, but the subfolder does not exist in the repo,
        and the requests succeeds, but yields empty data, `None` is returned.
    &#34;&#34;&#34;

    def console(*msg, error=False, newline=True):
        consoleKit(*msg, error=error, newline=newline, indent=indent)

    conn = None

    bUrl = f&#34;https://{backend}&#34;
    onlineSrc = f&#34;{bUrl}/{org}/{repo}&#34;
    person = os.environ.get(GLPERS(backend), None)

    if person:
        conn = Gitlab(bUrl, private_token=person, keep_base_url=True)
    else:
        conn = Gitlab(bUrl)

    backendVersion = conn.version()

    if (
        not backendVersion
        or backendVersion[0] == &#34;unknown&#34;
        or backendVersion[-1] == &#34;unknown&#34;
    ):
        conn = None
        console(f&#34;cannot connect to GitLab instance {bUrl}\n&#34;, error=True)
        return False

    if verbose:
        console(f&#34;connected to {bUrl}&#34;)

    repoOnline = None

    try:
        repoOnline = conn.projects.get(f&#34;{org}/{repo}&#34;)
    except Exception as e:
        console(f&#34;connecting failed to online {onlineSrc}&#34;, error=True)

        if type(e) is GitlabGetError:
            console(f&#34;{bUrl} says: {e}&#34;, error=True)
        else:
            console(f&#34;error with {bUrl}: {e}&#34;, error=True)

        return False

    if verbose:
        console(f&#34;connected to {onlineSrc}&#34;)

    commit = None

    try:
        cs = repoOnline.commits.list(all=True)

        if not len(cs):
            console(f&#34;no commit in {onlineSrc}&#34;, error=True)
        else:
            cs = sorted(cs, key=lambda x: x.created_at)

            if len(cs):
                commit = cs[-1]
    except Exception as e:
        console(str(e), error=True)

    if commit is None:
        console(f&#34;cannot find commits in {onlineSrc}&#34;, error=True)
        return False

    sha = commit.id

    if verbose:
        console(f&#34;{sha} = latest commit online&#34;)

    destDir = os.path.expanduser(destDir)
    (folderHead, folderTail) = folder.rsplit(&#34;/&#34;, 1) if &#34;/&#34; in folder else (&#34;&#34;, folder)

    folderLocal = f&#34;{destDir}/{folderTail}&#34;
    existingSha = readSha(folderLocal)

    if verbose:
        console(f&#34;{existingSha} = commit of local copy&#34;)

    localOk = existingSha == sha
    removeLocal = False

    if localOk:
        if verbose:
            console(&#34;Offline copy already up to date&#34;)

        if not force:
            return True
        else:
            console(&#34;Will download again over local copy&#34;)
    else:
        if verbose:
            console(&#34;Offline copy not up to date, will download new copy&#34;)

        removeLocal = True

    try:
        if verbose:
            console(f&#34;Downloading {onlineSrc}/{folder} ... &#34;, newline=False)

        response = conn.http_get(
            f&#34;/projects/{repoOnline.id}/repository/archive.zip&#34;,
            query_data=dict(path=folder),
            raw=True,
        )
        zf = response.content
    except Exception as e:
        if verbose:
            console(&#34;failed&#34;, error=True)

        console(str(e), error=True)
        return False

    if verbose:
        console(&#34;done&#34;)

    if len(zf) == 0:
        console(&#34;Download is empty&#34;)
        return None

    initTree(folderLocal, fresh=removeLocal)

    if verbose:
        console(f&#34;Extracting data to {folderLocal} ... &#34;, newline=False)

    try:
        zf = io.BytesIO(zf)
        z = ZipFile(zf)

        folderHeadSlash = f&#34;{folderHead}/&#34; if folderHead else &#34;&#34;
        gitlabSlugRe = re.compile(f&#34;^{repo}(?:-(?:master|main))?-[^/]*/&#34;)

        for zInfo in z.infolist():
            fileName = zInfo.filename

            if fileName.endswith(&#34;/&#34;):
                continue

            fileName = gitlabSlugRe.sub(&#34;&#34;, fileName) or &#34;/&#34;
            fileName = fileName.removeprefix(folderHeadSlash)
            zInfo.filename = fileName
            z.extract(zInfo, path=destDir)

        writeSha(folderLocal, sha)

    except Exception as e:
        if verbose:
            console(&#34;failed&#34;, error=True)

        console(str(e), error=True)
        return False

    if verbose:
        console(&#34;done&#34;)

    return True</code></pre>
</details>
</dd>
<dt id="ti.kit.repo.initTree"><code class="name flex">
<span>def <span class="ident">initTree</span></span>(<span>path, fresh=False, gentle=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L19-L26" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def initTree(path, fresh=False, gentle=False):
    exists = os.path.exists(path)

    if fresh and exists:
        rmtree(path)

    if not exists or fresh:
        os.makedirs(path, exist_ok=True)</code></pre>
</details>
</dd>
<dt id="ti.kit.repo.readSha"><code class="name flex">
<span>def <span class="ident">readSha</span></span>(<span>folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L33-L46" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readSha(folder):
    path = f&#34;{folder}/{CHECK_FILE}&#34;
    commit = None

    if os.path.isfile(path):
        with open(path) as f:
            for line in f:
                text = line.strip()

                if text:
                    commit = text
                    break

    return commit</code></pre>
</details>
</dd>
<dt id="ti.kit.repo.writeSha"><code class="name flex">
<span>def <span class="ident">writeSha</span></span>(<span>folder, commit)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/annotation/text-info/blob/33342169de3bd239caf6dd1d6feaca270365432f/ti/kit/repo.py#L49-L56" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writeSha(folder, commit):
    path = f&#34;{folder}/{CHECK_FILE}&#34;

    if not os.path.isdir(folder):
        os.makedirs(folder, exist_ok=True)

    with open(path, mode=&#34;w&#34;) as f:
        f.write(f&#34;{commit}\n&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<p><a href="https://github.com/annotation" title="annotation on GitHub"><img src="../../ti/images/tf-small.png" alt="annotation"></a></p>
<p><a href="../../ti/index.html">ti home</a> -
<a href="../../ti/cheatsheet.html">cheat sheet</a> -
<a href="https://github.com/annotation/text-info" title="GitHub repo"><img src="../../ti/images/GitHub_Logo.png" alt="GitHub" width="50"></a></p>
</p>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ti.kit" href="index.html">ti.kit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="ti.kit.repo.GLPERS" href="#ti.kit.repo.GLPERS">GLPERS</a></code></li>
<li><code><a title="ti.kit.repo.downloadZip" href="#ti.kit.repo.downloadZip">downloadZip</a></code></li>
<li><code><a title="ti.kit.repo.fetchRepo" href="#ti.kit.repo.fetchRepo">fetchRepo</a></code></li>
<li><code><a title="ti.kit.repo.initTree" href="#ti.kit.repo.initTree">initTree</a></code></li>
<li><code><a title="ti.kit.repo.readSha" href="#ti.kit.repo.readSha">readSha</a></code></li>
<li><code><a title="ti.kit.repo.writeSha" href="#ti.kit.repo.writeSha">writeSha</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<a href="https://pure.knaw.nl/portal/en/persons/dirk-roorda">Dirk Roorda</a>
<a href="https://huc.knaw.nl"><img alt="HuC" src="../../ti/images/huc.png" width="200" alt="Humanities Cluster"></a>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
